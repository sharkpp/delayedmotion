{"version":3,"sources":["serviceWorker.js","views/UploadImage.js","views/SelectArea.js","views/DownloadImage.js","misc/constants.js","App.js","index.js"],"names":["Boolean","window","location","hostname","match","onNextStep","useDropzone","accept","onDrop","files","reader","FileReader","onload","image","Image","src","result","readAsDataURL","rejectedFiles","getRootProps","getInputProps","rejectedFilesItems","map","file","key","path","className","useState","createRef","canvasRef","canvasMaskRef","canvasOffscreenRef","crop","setCrop","useEffect","canvas","current","width","height","getContext","drawImage","canvasOffscreen","handleChangeArea","useCallback","newCrop","ctx","scale","clientWidth","ctxOffscreen","canvasMask","ctxMask","fillStyle","fillRect","beginPath","ellipse","Math","PI","fill","maskData","getImageData","data","xyStep","xOffset","x","xMax","yOffset","y","yMax","floor","yi","xi","random","handleAreaLock","toBlob","imageBlob","Text","Button","onClick","renderComponent","ref","style","onChange","onComplete","display","FileDownload","require","prevewImage","setPrevewImage","e","target","handleDownload","Step","UploadImage","SelectArea","DownloadImage","Steps","title","App","step","setStep","setImage","image2","setImage2","handelUploadImageFinish","selectedImage","handelSelectAreaFinish","generatedImage","steps","activeStep","Body","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"6OAcoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,yECbS,G,MAAA,YAA2B,IAAfC,EAAc,EAAdA,WAAc,EAoBnCC,YAAY,CACdC,OAAQ,wBACRC,OApBiB,SAACC,GAClB,GAAIA,EAAM,GAAI,CACZ,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,WACd,IAAMC,EAAQ,IAAIC,MAClBD,EAAME,IAAML,EAAOM,OACnBH,EAAMD,OAAS,WACbP,EAAWQ,KAGfH,EAAOO,cAAcR,EAAM,QAK7BS,EAjBqC,EAiBrCA,cACAC,EAlBqC,EAkBrCA,aACAC,EAnBqC,EAmBrCA,cAMIC,EAAqBH,EAAcI,KAAI,SAAAC,GAAI,OAC/C,wBAAIC,IAAKD,EAAKE,MACXF,EAAKE,KADR,8DAKF,OACE,oCACE,wBAASN,EAAa,CAACO,UAAW,aAChC,0BAAWN,KACX,uMACA,wGAEF,4BACGC,M,iCCvCM,G,MAAA,YAAkC,IAAtBhB,EAAqB,EAArBA,WAAYQ,EAAS,EAATA,MAAS,EAEVc,mBAASC,uBAFC,mBAEtCC,EAFsC,aAGFF,mBAASC,wBAHP,mBAGtCE,EAHsC,aAIQH,mBAASC,wBAJjB,mBAItCG,EAJsC,aAKtBJ,mBAAS,KALa,mBAKvCK,EALuC,KAKjCC,EALiC,KAO9CC,qBAAU,WAGR,IAAMC,EAASN,EAAUO,QACzBD,EAAOE,MAAQxB,EAAMwB,MACrBF,EAAOG,OAAQzB,EAAMyB,OACNH,EAAOI,WAAW,MAC7BC,UAAU3B,EAAO,EAAG,EAAGA,EAAMwB,MAAOxB,EAAMyB,QAE9C,IAAMG,EAAkBV,EAAmBK,QAC3CK,EAAgBJ,MAAQxB,EAAMwB,MAC9BI,EAAgBH,OAAQzB,EAAMyB,SAE7B,CAACzB,IAGJ,IAAM6B,EAAmBC,uBAAY,SAACC,GACpC,IAAMT,EAASN,EAAUO,QACnBS,EAASV,EAAOI,WAAW,MAC3BO,EAASjC,EAAMwB,MAAQF,EAAOY,YAE9BN,EAAkBV,EAAmBK,QACrCY,EAAkBP,EAAgBF,WAAW,MACnDS,EAAaR,UAAU3B,EAAO,EAAG,EAAGA,EAAMwB,MAAOxB,EAAMyB,QAEvD,IAAMW,EAAanB,EAAcM,QACjCa,EAAWZ,MAAQL,EAAKK,MAAS,EACjCY,EAAWX,OAAQN,EAAKM,OAAS,EACjC,IAAMY,EAAaD,EAAWV,WAAW,MAEzC,KAAIU,EAAWZ,MAAQ,GAAKY,EAAWX,OAAS,GAAhD,CAIAY,EAAQC,UAAY,UACpBD,EAAQE,SAAS,EAAG,EAAGH,EAAWZ,MAAOY,EAAWX,QACpDY,EAAQC,UAAY,UACpBD,EAAQG,YACRH,EAAQI,QAAQL,EAAWZ,MAAQ,EAAGY,EAAWX,OAAS,EAAGW,EAAWZ,MAAQ,EAAI,GAAKY,EAAWX,OAAS,EAAI,GAAK,EAAG,EAAG,EAAIiB,KAAKC,IACrIN,EAAQO,OACR,IAAMC,EAAWR,EAAQS,aAAa,EAAG,EAAGV,EAAWZ,MAAOY,EAAWX,QAAQsB,KAE3EC,EAAU,EAAIf,EACdgB,EAAU9B,EAAK+B,EAAIjB,EACnBkB,EAAUF,EAAU9B,EAAKK,MAAQS,EACjCmB,EAAUjC,EAAKkC,EAAIpB,EACnBqB,EAAUF,EAAUjC,EAAKM,OAASQ,EAExCE,EAAaG,UAAY,iBACzBH,EAAaI,SAASpB,EAAK+B,EAAIjB,EAAOd,EAAKkC,EAAIpB,EAAOS,KAAKa,OAAOpC,EAAKK,MAAQ,GAAK,GAAKwB,EAAQN,KAAKa,OAAOpC,EAAKM,OAAS,GAAK,GAAKuB,GAErI,IAAK,IAAIK,EAAID,EAASI,EAAK,EAAGH,EAAIC,EAAMD,GAAKL,IAAUQ,EACrD,IAAK,IAAIN,EAAID,EAASQ,EAAK,EAAGP,EAAIC,EAAMD,GAAKF,IAAUS,EACjD,GAAKZ,EAAwC,GAA9BY,EAAKD,EAAKpB,EAAWZ,OAAa,IAAMkB,KAAKgB,SAAW,KACzEvB,EAAaG,UAAY,UACzBH,EAAaI,SAASW,EAAGG,EAAGL,EAASf,EAAOe,EAASf,IAK3DD,EAAIL,UAAUC,EAAiB,EAAG,MAEjC,CAACZ,EAAWE,EAAoBD,EAAeE,IAG5CwC,EAAiB7B,uBAAY,WAClBd,EAAUO,QAClBqC,QAAO,SAACC,GACbrE,EAAWqE,KACV,aAAc,MAChB,CAAC7D,EAAOmB,IAEX,OACE,oCACE,kBAAC,IAAK2C,KAAN,KACA,kBAACC,EAAA,EAAD,CAAQC,QAASL,GAAjB,4BAGE,kBAAC,IAAD,CACEM,gBACE,4BAAQC,IAAKlD,EAAWmD,MAAO,CAAE3C,MAAO,UAE1CL,KAAMA,EACNiD,SAAU,SAAArC,GAAO,OAAIX,EAAQW,IAC7BsC,WAAY,kBAAMxC,QAGtB,4BAAQqC,IAAKhD,EAAoBiD,MAAO,CAAE3C,MAAO,OAAQ8C,QAAS,UAClE,4BAAQJ,IAAKjD,EAAekD,MAAO,CAAEG,QAAS,aClG9CC,EAAeC,EAAQ,IAEd,cAAsB,IAAVxE,EAAS,EAATA,MAAS,EAEMc,mBAAS,IAFf,mBAE1B2D,EAF0B,KAEbC,EAFa,KAIlCrD,qBAAU,WACR,IAAMxB,EAAS,IAAIC,WACnBD,EAAOE,OAAS,SAAC4E,GACfD,EAAeC,EAAEC,OAAOzE,SAE1BN,EAAOO,cAAcJ,KACpB,CAACA,IAEJ,IAAM6E,EAAiB/C,uBAAY,WACjCyC,EAAavE,EAAO,aAAc,gBACjC,CAACA,IAEJ,OACE,qDAEE,yBAAKE,IAAKuE,EAAaN,MAAO,CAAE3C,MAAO,UACvC,kBAACuC,EAAA,EAAD,CAAQC,QAASa,GAAjB,cCvBOC,EAAO,CAClBC,YAAe,EACfC,WAAe,EACfC,cAAe,GCOXC,EAAQ,CACZ,CAAEC,MAAO,0DACT,CAAEA,MAAO,oDACT,CAAEA,MAAO,iBAmCIC,MAhCf,WAAgB,IAAD,EAEetE,mBAASgE,EAAKC,aAF7B,mBAELM,EAFK,KAEEC,EAFF,OAGexE,mBAAS,MAHxB,mBAGLd,EAHK,KAGEuF,EAHF,OAIiBzE,mBAAS,MAJ1B,mBAIL0E,EAJK,KAIGC,EAJH,KAMPC,EAA0B5D,uBAAY,SAAC6D,GAC3CJ,EAASI,GACTL,EAAQR,EAAKE,eAGTY,EAAyB9D,uBAAY,SAAC+D,GAC1CJ,EAAUI,GACVP,EAAQR,EAAKG,kBAGf,OACE,yBAAKpE,UAAU,OACP,kBAAC,IAAD,CAASiF,MAAOZ,EAAOa,WAAYV,IACzC,kBAAC,IAAD,KACE,kBAAC,IAAKW,KAAN,KACG,CACC,kBAACjB,EAAD,CAAiBvF,WAAYkG,IAC7B,kBAACV,EAAD,CAAiBxF,WAAYoG,EAAyB5F,MAAOA,IAC7D,kBAACiF,EAAD,CAAoBjF,MAAOwF,KAC3BH,OChCZY,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SNuH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.f1b68ab0.chunk.js","sourcesContent":["\"use struct\";\n\n// このオプションのコードは、Service Workerを登録するために使用されます。\n// register() はデフォルトでは呼び出されません。\n\n// これにより、その後の実稼働時のアクセスでアプリの読み込みが速くなり、\n// オフライン機能が提供されます。 ただし、開発者（およびユーザー）は、\n// 以前にキャッシュされたリソースがバックグラウンドで更新されるため、\n// ページで開いている既存のタブがすべて閉じられた後、ページへの以降の\n// アクセスでのみ展開された更新が表示されます。\n\n// このモデルの利点とオプトイン方法の詳細については、\n// https://bit.ly/CRA-PWA をご覧ください。\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] は IPv6 localhost アドレスです。\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 は IPv4 のローカルホストと見なされます。\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // URLコンストラクターは、SWをサポートするすべてのブラウザーで使用できます。\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // PUBLIC_URL がページの配信元と異なる発信元にある場合サービスワーカーは機能しません。\n      // これは、アセットの提供にCDNが使用されている場合に発生する可能性があります。\n      // https://github.com/facebook/create-react-app/issues/2374 を参照してください\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // これはローカルホストで実行されています。 Service Workerがまだ存在するかどうかを確認しましょう。\n        checkValidServiceWorker(swUrl, config);\n\n        // いくつかの追加のログを localhost に追加し、開発者に\n        // service worker/PWA ドキュメントを参照させます。\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // ローカルホストではありません。サービスワーカーを登録するだけです。\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // この時点で更新された事前キャッシュされたコンテンツが取得されましたが、\n              // 以前のサービスワーカーは、すべてのクライアントタブが閉じられるまで\n              // 古いコンテンツを引き続き提供します。\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // コールバックを実行\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // この時点ですべてが事前にキャッシュされています。\n              // \"コンテンツはオフラインで使用するためにキャッシュされます。\"\n              // メッセージを表示するのに最適なタイミングです。\n              console.log('Content is cached for offline use.');\n\n              // コールバックを実行\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // ページをリロードできない場合、サービスワーカーが見つかるかどうかを確認します。\n  fetch(swUrl)\n    .then(response => {\n      // Service Worker が存在し、JSファイルを実際に取得していることを確認してください。\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // サービスワーカーが見つかりません。おそらく別のアプリ。ページをリロード。\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // サービスワーカーが見つかりました。通常どおり続行。\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","\"use struct\";\n\nimport React from 'react';\n\nimport {useDropzone} from 'react-dropzone'\nimport 'react-dropzone/examples/theme.css';\n\nexport default function ({ onNextStep }) {\n\n  const handleDrop = (files) => {\n    if (files[0]) {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const image = new Image();\n        image.src = reader.result;\n        image.onload = () => {\n          onNextStep(image);\n        }\n      }\n      reader.readAsDataURL(files[0]);\n    }\n  };\n\n  const {\n    rejectedFiles,\n    getRootProps,\n    getInputProps\n  } = useDropzone({\n    accept: 'image/jpeg, image/png',\n    onDrop: handleDrop\n  });\n\n  const rejectedFilesItems = rejectedFiles.map(file => (\n    <li key={file.path}>\n      {file.path} は利用できません。\n    </li>\n  ));\n\n  return (\n    <>\n      <div {...getRootProps({className: 'dropzone'})}>\n        <input {...getInputProps()} />\n        <p>画像をここにドロップするか、クリックして選択してください</p>\n        <em>jpeg もしくは png のみ指定可能)</em>\n      </div>\n      <ol>\n        {rejectedFilesItems}\n      </ol>\n    </>\n  );\n}\n","\"use struct\";\n\nimport React, { useState, useEffect, useCallback, createRef } from 'react';\nimport { Button, Card } from 'react-bootstrap';\nimport ReactCrop from 'react-image-crop';\nimport 'react-image-crop/dist/ReactCrop.css';\n\nexport default function ({ onNextStep, image }) {\n\n  const [ canvasRef, setCanvasRef ] = useState(createRef());\n  const [ canvasMaskRef, setCanvasMaskRef ] = useState(createRef());\n  const [ canvasOffscreenRef, setCanvasOffscreenRef ] = useState(createRef());\n  const [crop, setCrop] = useState({ });\n\n  useEffect(() => {\n\n    // 画像を描画\n    const canvas = canvasRef.current;\n    canvas.width = image.width;\n    canvas.height= image.height;\n    const ctx    = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0, image.width, image.height);\n\n    const canvasOffscreen = canvasOffscreenRef.current;\n    canvasOffscreen.width = image.width;\n    canvasOffscreen.height= image.height;\n\n  }, [image]);\n\n  // 範囲変更\n  const handleChangeArea = useCallback((newCrop) => {\n    const canvas = canvasRef.current;\n    const ctx    = canvas.getContext('2d');\n    const scale  = image.width / canvas.clientWidth;\n\n    const canvasOffscreen = canvasOffscreenRef.current;\n    const ctxOffscreen    = canvasOffscreen.getContext('2d');\n    ctxOffscreen.drawImage(image, 0, 0, image.width, image.height);\n\n    const canvasMask = canvasMaskRef.current;\n    canvasMask.width = crop.width  / 5;\n    canvasMask.height= crop.height / 5;\n    const ctxMask    = canvasMask.getContext('2d');\n\n    if (canvasMask.width < 1 || canvasMask.height < 1) {\n      return;\n    }\n\n    ctxMask.fillStyle = '#000000';\n    ctxMask.fillRect(0, 0, canvasMask.width, canvasMask.height);\n    ctxMask.fillStyle = '#FF0000';\n    ctxMask.beginPath();\n    ctxMask.ellipse(canvasMask.width / 2, canvasMask.height / 2, canvasMask.width / 2 * 0.9, canvasMask.height / 2 * 0.9, 0, 0, 2 * Math.PI);\n    ctxMask.fill();\n    const maskData = ctxMask.getImageData(0, 0, canvasMask.width, canvasMask.height).data; // [ R(0,0), G(0,0), B(0,0), alpha(0,0), ... ]\n\n    const xyStep  = 5 * scale;\n    const xOffset = crop.x * scale;\n    const xMax    = xOffset + crop.width * scale;\n    const yOffset = crop.y * scale;\n    const yMax    = yOffset + crop.height * scale;\n\n    ctxOffscreen.fillStyle = 'rgb(0,0,0,0.5)';\n    ctxOffscreen.fillRect(crop.x * scale, crop.y * scale, Math.floor((crop.width + 1) / 5) * xyStep, Math.floor((crop.height + 1) / 5) * xyStep);\n\n    for (let y = yOffset, yi = 0; y < yMax; y += xyStep, ++yi) {\n      for (let x = xOffset, xi = 0; x < xMax; x += xyStep, ++xi) {\n        if (0 == maskData[(xi + yi * canvasMask.width) * 4 + 0] && Math.random() < 0.3) {\n          ctxOffscreen.fillStyle = '#FFFFFF';\n          ctxOffscreen.fillRect(x, y, xyStep + scale, xyStep + scale);\n        }\n      }\n    }\n\n    ctx.drawImage(canvasOffscreen, 0, 0);\n\n  }, [canvasRef, canvasOffscreenRef, canvasMaskRef, crop]);\n\n  // 範囲確定\n  const handleAreaLock = useCallback(() => {\n    const canvas = canvasRef.current;\n    canvas.toBlob((imageBlob) => {\n      onNextStep(imageBlob);\n    }, 'image/jpeg', 0.9);\n  }, [image, crop]);\n    \n  return (\n    <>\n      <Card.Text>\n      <Button onClick={handleAreaLock} >\n        選択完了\n      </Button>\n        <ReactCrop\n          renderComponent={\n            <canvas ref={canvasRef} style={{ width: '100%' }} />\n          }\n          crop={crop}\n          onChange={newCrop => setCrop(newCrop)}\n          onComplete={() => handleChangeArea()}\n        />\n      </Card.Text>\n      <canvas ref={canvasOffscreenRef} style={{ width: '100%', display: 'none' }} />\n      <canvas ref={canvasMaskRef} style={{ display: 'none' }} />\n    </>\n  );\n}\n","\"use struct\";\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Button } from 'react-bootstrap';\nconst FileDownload = require('js-file-download');\n\nexport default function ({ image }) {\n\n  const [ prevewImage, setPrevewImage ] = useState('');\n\n  useEffect(() => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      setPrevewImage(e.target.result);\n    };\n    reader.readAsDataURL(image);\n  }, [image]);\n\n  const handleDownload = useCallback(() => {\n    FileDownload(image, 'sample.jpg', 'image/jpeg');\n  }, [image]);\n\n  return (\n    <>\n      download image\n      <img src={prevewImage} style={{ width: '100%' }} />\n      <Button onClick={handleDownload} >\n        Download\n      </Button>\n    </>\n  );\n}\n","\"use struct\";\n\n// 処理のステップの状態\nexport const Step = {\n  UploadImage:   0,\n  SelectArea:    1,\n  DownloadImage: 2,\n};\n","\"use struct\";\n\nimport React, { useState, useCallback } from 'react';\nimport './App.css';\nimport Card from 'react-bootstrap/Card'\nimport Stepper from 'react-stepper-horizontal';\n\nimport UploadImageView from './views/UploadImage';\nimport SelectAreaView from './views/SelectArea';\nimport DownloadImageView from './views/DownloadImage';\n\nimport { Step } from './misc/constants';\n\nconst Steps = [\n  { title: '画像をアップロード' },\n  { title: '揺らす範囲を設定' },\n  { title: '完成'}\n];\n\nfunction App() {\n\n  const [ step,  setStep  ] = useState(Step.UploadImage);\n  const [ image, setImage ] = useState(null);\n  const [ image2, setImage2 ] = useState(null);\n\n  const handelUploadImageFinish = useCallback((selectedImage) => {\n    setImage(selectedImage);\n    setStep(Step.SelectArea);\n  });\n\n  const handelSelectAreaFinish = useCallback((generatedImage) => {\n    setImage2(generatedImage);\n    setStep(Step.DownloadImage);\n  });\n\n  return (\n    <div className=\"App\">\n            <Stepper steps={Steps} activeStep={step} />\n      <Card>\n        <Card.Body>\n          {[\n            <UploadImageView onNextStep={handelUploadImageFinish} />,\n            <SelectAreaView  onNextStep={handelSelectAreaFinish}  image={image} />,\n            <DownloadImageView  image={image2} />\n          ][step]}\n        </Card.Body>\n      </Card>\n    </div>\n  );\n}\n\nexport default App;\n","\"use struct\";\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport * as serviceWorker from './serviceWorker';\n\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './index.css';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// アプリをオフラインで動作させてより速くロードしたい場合は、以下で unregister() を\n// register() に変更できます。これにはいくつかの落とし穴があります。\n// サービスワーカーの詳細: https://bit.ly/CRA-PWA\n\nserviceWorker.unregister();\n\n// 要求スペック\n//   config#onUpdate(registration);\n//   config#onSuccess(registration);\n// serviceWorker.register(config);\n"],"sourceRoot":""}